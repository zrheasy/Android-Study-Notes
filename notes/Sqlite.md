# Sqlite数据库简介

Sqlite是一种轻量级的本地数据库，传统的数据库如MySQL等需要运行在独立的进程中使用，而Sqlite则是运行在应用进程中作为本地数据库来使用减少了跨进程通信消耗，所以其非常的轻量和高效，在移动端和嵌入式有广泛的应用。

## Sqlite线程模式
Sqlite支持3中线程模式：单线程、多线程、串行模式。

### 单线程模式
这种模式下Sqlite禁用所有的mutex锁，多线程并发使用时会出错。可以在编译时或初始化时指定。

### 多线程模式
这种模式下Sqlite禁用了数据库连接和Prepared Statement上的锁，因此在多线程下使用同一个数据库连接或Prepared Statement就会出错。可在编译时、初始化时或连接数据库时指定。

### 串行模式
这种模式下Sqlite启用了所有的锁，因此多线程访问是安全的，所有的数据库操作都变成了串行执行。


## Sqlite锁
SQLite 采用粗放型的锁。当一个连接要写数据库，所有其他的连接被锁住，直到写连接结束了它的事务。SQLite 有一个加锁表，来帮助不同的写数据库者能够在最后一刻再加锁，以保证最大的并发性。

SQLite 使用锁逐步上升机制，为了写数据库，连接需要逐步地获得排它锁。 SQLite 有 5 个不同的锁状态：未加锁(UNLOCKED)、共享(SHARED)、保留(RESERVED)、未决(PENDING)和排它(EXCLUSIVE)。每个数据库连接在同一时刻只能处于其中一个状态。每种状态(未加锁状态除外)都有一种锁与之对应。

产生死锁的四个必要条件：
（1） 互斥条件：一个资源每次只能被一个进程使用。
（2） 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。
（3） 不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺。
（4） 循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。
这四个条件是死锁的必要条件，只要系统发生死锁，这些条件必然成立，而只要上述条件之一不满足，就不会发生死锁。

## Sqlite事务
数据库事务的四大特性：

### 原子性（Atomicity）
原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚，因此事务的操作如果成功就必须要完全应用到数据库，如果操作失败则不能对数据库有任何影响。

### 一致性（Consistency）
一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态。

### 隔离性（Isolation）
隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。

### 持久性（Durability）
持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。

Sqlite事务由3个命令控制：BEGIN、COMMIT和ROLLBACK。BEGIN开始一个事务，之后的所有操作都可以取消。COMMIT使BEGIN后的所有命令得到确认；而ROLLBACK还原BEGIN之后的所有操作。

### 数据库并发访问时出现的问题：
脏读：指在一个事务处理过程里读取了另一个未提交的事务中的数据。

不可重复读：指在对于数据库中的某个数据，一个事务范围内多次查询却返回了不同的数据。

幻读：幻读是事务非独立执行时发生的一种现象。简单说就是读的时候插入了一条新数据，导致再读时多了一条。

不可重复读和幻读是读取了已提交的事务数据，而脏读时读取了未提交的事务数据。

